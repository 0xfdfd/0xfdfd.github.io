---
title: 记一次由于头文件版本映射引入的死机问题
date: 2021-08-16T08:37:49+08:00
tags:
---

蜂鸟平台基线项目中出现了极其偶发性的死机问题，本文章回溯了整个问题的排查过程。

<!-- more -->

## 时间线

* 2021-06-29 测试团队发现蜂鸟设备清配置重启过程中偶现性的死机，问题单提为严重级别
* 2021-06-30 蜂鸟团队投入分析
  * 经过一个月的自动化测试，复现了若干次问题，但是一直未找到提升问题复现概率的方法以及问题根因
  * 期间与产品线沟通，产品线经过4000次自动化测试，均未复现问题，认为是一个轻微级别的问题
* 2021-08-12 蜂鸟团队进行下一轮测试的转测工作
* 2021-08-13 转测过程中发现智能相关业务也存在死机问题
  * 死机现象类似
  * 高概率出现
  * 问题解决

## 过程分析

### 死机堆栈

死机的堆栈十分稳定，出现在下述代码中的第16行，即对 `msg` 解引用的时候：

```c
// msg 是承载了消息内容的一个对象

uint64 t1 = aeda_timeGetCurrentMillSecond();
switch (msg->type)
{
    // 此处依据消息内容，回调给用户进行处理
}
uint64_t t2 = aeda_timeGetCurrentMilliSecond();

/************************************************************************/
/* 处理超时时显示告警                                                    */
/************************************************************************/
uint64_t timeDiff = t2 - t1;
if (timeDiff > aeda_softbus_timeout)
{
	switch (msg->type)  // 此处发生死机，值为NULL
	{
        // 打印告警信息
	}
}
```

## 现象推导

从上述堆栈中我们可以获取到几个信息：
1. 问题原因必定为内存被踩。这是由于在上述代码的第4行同样对 `msg` 发生了解引用，但是未出现死机。这说明在第4行的时候， `msg` 这个变量所包含的值还是正常的；但是到了第16行解引用却发生了死机，说明变量值被意外改变，而这两者之间进行了用户回调。
2. 不太可能是由于多线程引起的内存被踩。这是由于多线程运行过程往往是不稳定的。如果是由于多线程问题内存被踩，那么死机堆栈应该会变化才对。而此处的多次复现均发现堆栈相同。
3. 可能是由于栈被踩导致的死机。与上一点类似，由于死机堆栈十分稳定，且此变量为栈上的变量，因此大概率是栈被踩。

从上述现象我们还能进一步推导栈是如何被踩的。

依据 {% post_link  Procedure-Call-Standard %} 可以知道 `ARM32` 下栈默认情况下是向下生长的（借用一下x86的图，AAPCS里面没画）：
```
direction of     |                                 |
  growth of      +---------------------------------+ 
   stack         | Parameters passed by fn1(caller)|
from higher addr.|                                 |
to lower addr.   | Direction of growth is opposite |
      |          |   to direction of stack growth  |
      |          +---------------------------------+ <-- SP on entry to fn2
      |          | Return address from fn2(callee) | 
      V          +---------------------------------+ 
                 | Callee saved registers being    | 
                 |   used in the callee function   | 
                 +---------------------------------+
                 | Local variables of fn2          |
                 |(Direction of growth of frame is |
                 | same as direction of growth of  |
                 |            stack)               |
                 +---------------------------------+ 
                 | Arguments to functions called   |
                 | by fn2                          |
                 +---------------------------------+ <- Current SP after stack 
                                                        frame is allocated
```

由于栈向下生长，而 `msg` 这个变量位于用户栈的高地址处，因此被踩原因必然不是因为栈溢出。这是因为栈溢出必定是向低地址踩，如果是由于栈溢出引起的，则必然是相对高地址处的另一个线程的栈溢出引起的，这就涉及到了2个线程。而前面提到过，此处稳定的死机堆栈不像是多线程引起的内存问题。

对于上一级栈的破坏主要是由于对于栈上变量的越界写引起的。举个例子，我们在栈上有一个数组：
```c
void foo(void)
{
    int arr[8];
}
```

则数组的首位 `arr[0]` 处于低地址，数组的末尾 `arr[7]` 处于高地址。对应到栈上就是：
```
STACK_TOP --> STACK_BOTTOM
LOW_ADD   -->    HIGH_ADDR
arr[0]    ...       arr[7]
```

因此，如果我们对变量 `arr` 向后越界写入，就会造成对上一级堆栈的破坏。

## 过程验证

上述推导在第一次死机的时候即可推导出来，但是由于问题现象极其偶现，无法找到具体位置。后续智能相关业务的高概率死机给了我们解决的希望。

智能死机所呈现的堆栈与前述一致，其主要提供了一些场外信息：
1. 由于高概率死机，我们可以对问题引入版本进行二分查找
2. 通过二分查找，发现问题引入版本在 `08/05` 与 `08/10` 之间
3. 产品线对应程序无问题，蜂鸟基线对应程序有问题
4. 从代码上看，产品线对应程序在这两个版本之间仅存在一处改动
5. 将此改动同步到基线，仍然出现死机问题

至此，其实问题的唯一原因已经明确：
在保持双方代码一致、依赖库版本一致的情况下，仍然出现栈越界写入死机，则应是头文件不匹配导致的问题。

这是因为我们可以有如下推导：
1. 代码保持一致，则代码逻辑应是正确的
2. 问题分析导向为栈溢出
3. 所集成的库是多个，通过映射方式指向同一份头文件，有存在版本不一致的可能

